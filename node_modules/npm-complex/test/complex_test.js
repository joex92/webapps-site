const Complex = require('./../src/complex.js').Complex;
const chai = require('chai');
const assert = chai.assert;

describe('Class Complex', function() {
  let complexOne,
  complexTwo;

  describe('Constructor', function() {
    it('Should yield 0+0i from no arguments', function() {
      complexOne = new Complex();
      assert.deepEqual(complexOne.getTuple(), [0, 0], 'Complex should yield 0+0i from no arguments!');
    });

    it('Should yield a+bi from arguments a, b', function() {
      complexOne = new Complex(1, 1);
      assert.deepEqual(complexOne.getTuple(), [1, 1], 'Complex should yield 1+1i from given arguments!');
      complexOne = new Complex(-1, 1);
      assert.deepEqual(complexOne.getTuple(), [-1, 1], 'Complex should yield -1+1i from given arguments!');
      complexOne = new Complex(-1, -1);
      assert.deepEqual(complexOne.getTuple(), [-1, -1], 'Complex should yield -1-1i from given arguments!');
      complexOne = new Complex(1, -1);
      assert.deepEqual(complexOne.getTuple(), [1, -1], 'Complex should yield 1+-1i from given arguments!');
    });

    it('Should throw an error from invalid types', function() {
      try {
        complexOne = new Complex('0', '0');
        assert.fail("Strings are not valid types!");
      }catch(err) {
        //passed test
      }

      try {
        complexOne = new Complex([0, 0]);
        assert.fail("Arrays are not valid types!");
      }catch(err) {
        //passed test
      }
    });

    it('Should throw an error from an invalid number of arguments', function() {
      try {
        complexOne = new Complex(0);
        assert.fail("Invalid number of arguments!");
      }catch(err) {
        //passed test
      }

      try {
        complexOne = new Complex(0, 0, 0);
        assert.fail("Invalid number of arguments!");
      }catch(err) {
        //passed test
      }
    });
  });

  describe('Getters', function() {
    describe('getReal', function() {
      it('Should yield the proper real component', function() {
        complexOne = new Complex();
        assert.strictEqual(complexOne.getReal(), 0, 'Default real component should be 0!');
        complexOne = new Complex(1, 0);
        assert.strictEqual(complexOne.getReal(), 1, 'Real component should be able to take positive numbers!');
        complexOne = new Complex(-1, 0);
        assert.strictEqual(complexOne.getReal(), -1, 'Real component should be able to take negative numbers!');
        complexOne = new Complex(Math.PI, 0);
        assert.strictEqual(complexOne.getReal(), Math.PI, 'Real component should be able to take constants!');
      });
    });

    describe('getImaginary', function() {
      it('Should yield the proper imaginary component', function() {
        complexOne = new Complex();
        assert.strictEqual(complexOne.getImaginary(), 0, 'Default imaginary component should be 0i!');
        complexOne = new Complex(0, 1);
        assert.strictEqual(complexOne.getImaginary(), 1, 'Imaginary component should be able to take positive numbers!');
        complexOne = new Complex(0, -1);
        assert.strictEqual(complexOne.getImaginary(), -1, 'Imaginary component should be able to take negative numbers!');
        complexOne = new Complex(0, Math.PI);
        assert.strictEqual(complexOne.getImaginary(), Math.PI, 'Imaginary component should be able to take constants!');
      });
    });

    describe('getTuple', function() {
      it('Should yield the corresponding tuple containing the real and imaginary components', function() {
        complexOne = new Complex();
        assert.deepEqual(complexOne.getTuple(), [0, 0], 'Default tuple should be (0, 0)!');
        complexOne = new Complex(1, 0);
        assert.deepEqual(complexOne.getTuple(), [1, 0], 'Corresponding tuple should be (1, 0)!');
        complexOne = new Complex(0, 1);
        assert.deepEqual(complexOne.getTuple(), [0, 1], 'Corresponding tuple should be (0, 1)!');
        complexOne = new Complex(-1, 0);
        assert.deepEqual(complexOne.getTuple(), [-1, 0], 'Corresponding tuple should be (-1, 0)!');
        complexOne = new Complex(0, -1);
        assert.deepEqual(complexOne.getTuple(), [0, -1], 'Corresponding tuple should be (0, -1)!');
      });
    });

    describe('getModulus', function() {
      it('Should always yield the proper modulus (magnitude)', function() {
        complexOne = new Complex();
        assert.strictEqual(complexOne.getModulus(), 0, 'Default modulus should be 0!');
        complexOne = new Complex(1, 1);
        assert.strictEqual(complexOne.getModulus(), Math.sqrt(2),
          'Modulus does not yield the proper value!');
        complexOne = new Complex(0, -1);
        assert.strictEqual(complexOne.getModulus(), 1,
          'Modulus should ignore sign on real and imaginary components!');
        complexOne = new Complex(-1, 0);
        assert.strictEqual(complexOne.getModulus(), 1,
          'Modulus should ignore sign on real and imaginary components!');
        complexOne = new Complex(-1, -1);
        assert.strictEqual(complexOne.getModulus(), Math.sqrt(2),
          'Modulus should ignore sign on real and imaginary components!');
      });
    });

    describe('getPS', function() {
      it('Should always yield the proper power spectrum', function() {
        complexOne = new Complex();
        assert.strictEqual(complexOne.getPS(), 0, 'Default power spectrum should be 0!');
        complexOne = new Complex(1, 1);
        assert.strictEqual(complexOne.getPS(), 2,
          'Power spectrum does not yield the proper value!');
        complexOne = new Complex(0, -1);
        assert.strictEqual(complexOne.getPS(), 1,
          'Power spectrum should ignore sign on real and imaginary components!');
        complexOne = new Complex(-1, 0);
        assert.strictEqual(complexOne.getPS(), 1,
          'Power spectrum should ignore sign on real and imaginary components!');
        complexOne = new Complex(-1, -1);
        assert.strictEqual(complexOne.getPS(), 2,
          'Power spectrum should ignore sign on real and imaginary components!');
      });
    });

    describe('getPhase', function() {
      it('Should always yield the proper phase shift (rotation)', function() {
        complexOne = new Complex();
        assert.strictEqual(complexOne.getPhase(), 0, 'Default phase shift should be 0 radians!');
        complexOne = new Complex(1, 0);
        assert.strictEqual(complexOne.getPhase(), 0, 'Phase shift should be 0!');
        complexOne = new Complex(0, 1);
        assert.strictEqual(complexOne.getPhase(), Math.PI/2, 'Phase shift should be PI/2!');
        complexOne = new Complex(-1, 0);
        assert.strictEqual(complexOne.getPhase(), Math.PI, 'Phase shift should be PI!');
        complexOne = new Complex(0, -1);
        assert.strictEqual(complexOne.getPhase(), 1.5 * Math.PI, 'Phase shift should be 3PI/2!');
        complexOne = new Complex(5, 0);
        assert.strictEqual(complexOne.getPhase(), 0, 'Phase shift should not depend on magnitude!');
      });
    });
  });

  describe('Setters', function() {
    describe('setReal', function() {
      it('Should accept any number as a real component', function() {
        complexOne = new Complex();
        complexOne.setReal(0);
        assert.strictEqual(complexOne.getReal(), 0, 'Real component should be 0!');
        complexOne.setReal(1);
        assert.strictEqual(complexOne.getReal(), 1, 'Real component should be 1!');
        complexOne.setReal(-1);
        assert.strictEqual(complexOne.getReal(), -1, 'Real component should be -1!');
        complexOne.setReal(Math.PI);
        assert.strictEqual(complexOne.getReal(), Math.PI, 'Real component should accept constants!');
        complexOne.setReal(new Number(0));
        assert.strictEqual(complexOne.getReal(), 0, 'Real component should accept instances of Number!');
      });

      it('Should handle invalid types by throwing TypeError', function() {
        complexOne = new Complex();
        try {
          complexOne.setReal([0]);
          assert.fail('Arrays are not accepted for real components!');
        }catch(err) {
          // passed test
        }

        try {
          complexOne.setReal('0');
          assert.fail('Strings are not accepted for real components!');
        }catch(err) {
          // passed test
        }
      });
    });

    describe('setImaginary', function() {
      it('Should accept any number as an imaginary component', function() {
        complexOne = new Complex();
        complexOne.setImaginary(0);
        assert.strictEqual(complexOne.getImaginary(), 0, 'Imaginary component should be 0!');
        complexOne.setImaginary(1);
        assert.strictEqual(complexOne.getImaginary(), 1, 'Imaginary component should be 1!');
        complexOne.setImaginary(-1);
        assert.strictEqual(complexOne.getImaginary(), -1, 'Imaginary component should be -1!');
        complexOne.setImaginary(Math.PI);
        assert.strictEqual(complexOne.getImaginary(), Math.PI, 'Imaginary component should accept constants!');
        complexOne.setImaginary(new Number(0));
        assert.strictEqual(complexOne.getImaginary(), 0, 'Imaginary component should accept instances of Number!');
      });

      it('Should handle invalid types by throwing TypeError', function() {
        complexOne = new Complex();
        try {
          complexOne.setImaginary([0]);
          assert.fail('Arrays are not accepted for imaginary components!');
        }catch(err) {
          // passed test
        }

        try {
          complexOne.setImaginary('0');
          assert.fail('Strings are not accepted for imaginary components!');
        }catch(err) {
          // passed test
        }
      });
    });

    describe('setTuple', function() {
      it('Should accept tuples of length two as valid arguments', function() {
        complexOne = new Complex();
        complexOne.setTuple([0, 0]);
        assert.deepEqual(complexOne.getTuple(), [0, 0], 'Tuple should be [0, 0]!');
        complexOne.setTuple([1, 1]);
        assert.deepEqual(complexOne.getTuple(), [1, 1], 'Tuple should be [1, 1]!');
        complexOne.setTuple([-1, -1]);
        assert.deepEqual(complexOne.getTuple(), [-1, -1], 'Tuple should be [-1, -1]!');
        complexOne.setTuple([Math.PI, Math.PI]);
        assert.deepEqual(complexOne.getTuple(), [Math.PI, Math.PI], 'Tuples should accept constants!');
        complexOne.setTuple([new Number(0), new Number(0)]);
        assert.deepEqual(complexOne.getTuple(), [0, 0], 'Tuples should accept instances of Number!');
      });

      it('Should handle invalid types by throwing TypeError', function() {
        complexOne = new Complex();
        try {
          complexOne.setTuple(0, 0);
          assert.fail('Numbers are not accepted in place of tuples!');
        }catch(err) {
          // passed test
        }

        try {
          complexOne.setImaginary('0', '0');
          assert.fail('Strings are not accepted in place of tuples!');
        }catch(err) {
          // passed test
        }
      });

      it('Should handle invalid tuple lengths by throwing ValueError', function() {
        complexOne = new Complex();
        try {
          complexOne.setTuple([0]);
          assert.fail('Tuple is an invalid length!');
        }catch(err) {
          // passed test
        }

        try {
          complexOne.setImaginary([0, 0, 0]);
          assert.fail('Tuple is an invalid length!');
        }catch(err) {
          // passed test
        }
      });
    });
  });

  describe('Operations', function() {
    describe('addReal', function() {
      it('Should add any number to the real component', function() {
        complexOne = new Complex();
        complexOne.addReal(1);
        assert.strictEqual(complexOne.getReal(), 1, 'Real component should be 1!');
        complexOne.addReal(-1);
        assert.strictEqual(complexOne.getReal(), 0, 'Real component should be 0!');
        complexOne.addReal(new Number(1));
        assert.strictEqual(complexOne.getReal(), 1, 'Real component should be 1!');
        complexOne.addReal(Math.PI);
        assert.strictEqual(complexOne.getReal(), (1 + Math.PI), 'Real component should be (1+PI)!');
      });

      it('Should handle invalid types by throwing a TypeError', function() {
        complexOne = new Complex();
        try {
          complexOne.addReal('1');
          assert.fail('Strings are not accepted in place of added real components!');
        }catch(err) {
          // test passed
        }

        try {
          complexOne.addReal([1]);
          assert.fail('Arrays are not accepted in place of added real components!');
        }catch(err) {
          // test passed
        }
      });
    });

    describe('addImaginary', function() {
      it('Should add any number to the imaginary component', function() {
        complexOne = new Complex();
        complexOne.addImaginary(1);
        assert.strictEqual(complexOne.getImaginary(), 1, 'Imaginary component should be 1!');
        complexOne.addImaginary(-1);
        assert.strictEqual(complexOne.getImaginary(), 0, 'Imaginary component should be 0!');
        complexOne.addImaginary(new Number(1));
        assert.strictEqual(complexOne.getImaginary(), 1, 'Imaginary component should be 1!');
        complexOne.addImaginary(Math.PI);
        assert.strictEqual(complexOne.getImaginary(), (1 + Math.PI), 'Imaginary component should be (1+PI)!');
      });

      it('Should handle invalid types by throwing a TypeError', function() {
        complexOne = new Complex();
        try {
          complexOne.addImaginary('1');
          assert.fail('Strings are not accepted in place of added imaginary components!');
        }catch(err) {
          // test passed
        }

        try {
          complexOne.addImaginary([1]);
          assert.fail('Arrays are not accepted in place of added imaginary components!');
        }catch(err) {
          // test passed
        }
      });
    });

    describe('addTuple', function() {
      it('Should add any tuple with valid types and length', function() {
        complexOne = new Complex();
        complexOne.addTuple([1, 1]);
        assert.deepEqual(complexOne.getTuple(), [1, 1], 'Tuple should be [1, 1]!');
        complexOne.addTuple([-1, -1]);
        assert.deepEqual(complexOne.getTuple(), [0, 0], 'Tuple should be [0, 0]!');
        complexOne.addTuple([new Number(1), new Number(1)]);
        assert.deepEqual(complexOne.getTuple(), [1, 1], 'Tuple should be [1, 1]!');
        complexOne.addTuple([Math.PI, Math.PI]);
        assert.deepEqual(complexOne.getTuple(), [(1 + Math.PI), (1 + Math.PI)], 'Tuple should be [(1+PI), (1+PI)]!');
      });

      it('Should handle invalid types by throwing a TypeError', function() {
        complexOne = new Complex();
        try {
          complexOne.addTuple('1, 1');
          assert.fail('Strings are not accepted in place of tuples!');
        }catch(err) {
          // test passed
        }

        try {
          complexOne.addImaginary(1, 1);
          assert.fail('Numbers are not accepted in place of tuples!');
        }catch(err) {
          // test passed
        }
      });

      it('Should handle invalid tuple lengths by throwing a ValueError', function() {
        complexOne = new Complex();
        try {
          complexOne.addTuple([0]);
          assert.fail('Tuple is an invalid length!');
        }catch(err) {
          // test passed
        }

        try {
          complexOne.addImaginary([0, 0, 0]);
          assert.fail('Tuple is an invalid length!');
        }catch(err) {
          // test passed
        }
      });
    });

    describe('multiplyReal', function() {
      it('Should multiply by any valid element on the field of real numbers', function() {
        complexOne = new Complex(1, 1);
        complexOne.multiplyReal(0);
        assert.deepEqual(complexOne.getTuple(), [0, 0], 'Scalar multiplication by 0 should yield [0, 0]!');
        complexOne = new Complex(1, 1);
        complexOne.multiplyReal(5);
        assert.deepEqual(complexOne.getTuple(), [5, 5], 'Scalar multiplication by 5 should yield [5, 5]!');
        complexOne = new Complex(1, 1);
        complexOne.multiplyReal(-5);
        assert.deepEqual(complexOne.getTuple(), [-5, -5], 'Scalar multiplication by -5 should yield [-5, -5]!');
        complexOne = new Complex(1, 1);
        complexOne.multiplyReal(new Number(5));
        assert.deepEqual(complexOne.getTuple(), [5, 5], 'Scalar multiplication by 5 (instance of Number) should yield [5, 5]!');
        complexOne = new Complex(1, 1);
        complexOne.multiplyReal(Math.PI);
        assert.deepEqual(complexOne.getTuple(), [Math.PI, Math.PI], 'Scalar multiplication by PI should yield [PI, PI]!');
      });

      it('Should handle invalid types by throwing TypeError', function() {
        complexOne = new Complex(0, 0);

        try {
          complexOne.multiplyReal('1');
          assert.fail('Strings cannot be used in place of numbers!');
        }catch(err) {
          // test passed
        }

        try {
          complexOne.multiplyReal([1]);
          assert.fail('Tuples cannot be used in place of numbers!');
        }catch(err) {
          // test passed
        }
      });
    });

    describe('multiplyImaginary', function() {
      it('Should multiply by any valid element on the field of complex numbers', function() {
        complexOne = new Complex(1, 1);
        complexOne.multiplyImaginary(0);
        assert.deepEqual(complexOne.getTuple(), [0, 0], 'Scalar multiplication by 0i should yield [0, 0]!');
        complexOne = new Complex(1, 1);
        complexOne.multiplyImaginary(5);
        assert.deepEqual(complexOne.getTuple(), [-5, 5], 'Scalar multiplication by 5i should yield [-5, 5]!');
        complexOne = new Complex(1, 1);
        complexOne.multiplyImaginary(-5);
        assert.deepEqual(complexOne.getTuple(), [5, -5], 'Scalar multiplication by -5i should yield [5, -5]!');
        complexOne = new Complex(1, 1);
        complexOne.multiplyImaginary(new Number(5));
        assert.deepEqual(complexOne.getTuple(), [-5, 5], 'Scalar multiplication by 5i (instance of Number) should yield [-5, 5]!');
        complexOne = new Complex(1, 1);
        complexOne.multiplyImaginary(Math.PI);
        assert.deepEqual(complexOne.getTuple(), [-Math.PI, Math.PI], 'Scalar multiplcation by (PI)i should yield [-PI, PI]!');
      });

      it('Should handle invalid types by throwing TypeError', function() {
        complexOne = new Complex(0, 0);

        try {
          complexOne.multiplyImaginary('1');
          assert.fail('Strings cannot be used in place of numbers!');
        }catch(err) {
          // test passed
        }

        try {
          complexOne.multiplyImaginary([1]);
          assert.fail('Tuples cannot be used in place of numbers!');
        }catch(err) {
          // test passed
        }
      });
    });

    describe('foil', function() {
      it('Should multiply by any valid element on the field of complex numbers', function() {
        complexOne = new Complex(1, 1);
        complexOne.foil([0, 0]);
        assert.deepEqual(complexOne.getTuple(), [0, 0], 'Foiling by [0, 0] should yield [0, 0]!');
        complexOne = new Complex(1, 1);
        complexOne.foil([5, 5]);
        assert.deepEqual(complexOne.getTuple(), [0, 10], 'Foiling by [5, 5] should yield [0, 10]!');
        complexOne = new Complex(1, 1);
        complexOne.foil([-5, -5]);
        assert.deepEqual(complexOne.getTuple(), [0, -10], 'Foiling by [-5, -5] should yield [0, -10]!');
        complexOne = new Complex(1, 1);
        complexOne.foil([-5, 5]);
        assert.deepEqual(complexOne.getTuple(), [-10, 0], 'Foiling by [-5, 5] should yield [-10, 0]!');
        complexOne = new Complex(1, 1);
        complexOne.foil([5, -5]);
        assert.deepEqual(complexOne.getTuple(), [10, 0], 'Foiling by [5, -5] should yield [10, 0]!');
      });

      it('Should handle invalid types by throwing TypeError', function() {
        complexOne = new Complex(0, 0);

        try {
          complexOne.foil('1', '1');
          assert.fail('Strings cannot be used in place of a tuple!');
        }catch(err) {
          // test passed
        }

        try {
          complexOne.multiplyImaginary(1, 1);
          assert.fail('Numbers cannot be used in place of a tuple!');
        }catch(err) {
          // test passed
        }

        try {
          complexOne.multiplyImaginary(['1', '1']);
          assert.fail('Elements of tuple cannot be Strings!');
        }catch(err) {
          // test passed
        }
      });

      it('Should handle tuples of improper length by throwing ValueError', function() {
        complexOne = new Complex(0, 0);

        try {
          complexOne.foil([1]);
          assert.fail('Tuple is of an invalid length!');
        }catch(err) {
          // test passed
        }

        try {
          complexOne.foil([1, 1, 1]);
          assert.fail('Tuple is of an invalid length!');
        }catch(err) {
          // test passed
        }
      });
    });
  });

  describe('Clone', function() {
    it('Should create a deep copy', function() {
      complexOne = new Complex(1, 1);
      complexTwo = complexOne.clone();

      assert.deepEqual(complexOne.getTuple(), complexTwo.getTuple(), 'Tuples from deep copy should equal in value!');
      assert.notStrictEqual(complexOne, complexTwo, 'Complex references from clone() should be separate!');
    });
  });

  describe('toString', function() {
    it('Should return the Complex number in standard form', function() {
      complexOne = new Complex();
      assert.strictEqual(complexOne.toString(), '0 + 0i', 'Standard form of default complex number should be 0 + 0i!');
      complexOne = new Complex(1, 1);
      assert.strictEqual(complexOne.toString(), '1 + 1i', 'Standard form should be 1 + 1i!');
      complexOne = new Complex(-1, -1);
      assert.strictEqual(complexOne.toString(), '-1 + -1i', 'Standard form should be 1 + -1i!');
    });
  });
});








