let copy = require('rfdc')();

class ValueError extends Error {
  constructor(msg) {
    super(msg)
    let _msg;

    this.toString = function() {
      return _msg;
    }
  }
}

/**
Holds instances of complex numbers, which
are composed of a real and an im component.
@author Noah Teshima
*/
class Complex {
  constructor(...args) {
    let _tuple = [0, 0];
    let that = this;

    this.getReal = function() {
      return _tuple[0];
    }

    this.setReal = function(re) {
      // We cover the case where a primitive is passed (no availalbe prototype
      // chain), as well as where an Object is passed, so the prototype chain
      // can be used with instanceof
      if(!(typeof re === 'number' || re instanceof Number)) {
        throw new TypeError(`${re} is not a valid number!`);
      }
      _tuple[0] = (re instanceof Number) ? re.valueOf() : re;
    }

    this.addReal = function(re) {
      that.addTuple([re, 0]);
    }

    this.getImaginary = function() {
      return _tuple[1];
    }

    this.setImaginary = function(im) {
      if(!(typeof im === 'number' || im instanceof Number)) {
        throw new TypeError(`${im} is not a valid number!`);
      }
      _tuple[1] = (im instanceof Number) ? im.valueOf() : im;
    }

    this.addImaginary = function(im) {
      that.addTuple([0, im]);
    }

    this.getTuple = function() {
      // Mildly misleading. ES6 currently has no support
      // for tuples, so lists are used as an alternative.
      return copy(_tuple);
    }

    this.setTuple = function(tuple) {
      if(!(tuple instanceof Array)) {
        throw new TypeError(`Type ${tuple} is not an instance of Array!`);
      }
      if(!(tuple.length === 2)) {
        throw new ValueError(`Invalid length of Array: ${tuple.length}`);
      }
      that.setReal(tuple[0]);
      that.setImaginary(tuple[1]);
    }

    this.addTuple = function(tuple) {
      that.setTuple([that.getReal() + tuple[0], that.getImaginary() + tuple[1]]);
    }

    this.getModulus = function() {
      // modulus is analogous to magnitude here
      return Math.sqrt(that.getPS());
    }

    this.getPhase = function() {
      // atan2 yields the phase in radians on the range of [-PI, PI]. We interpolate
      // this on the range [0, 2PI] instead
      return ((Math.atan2(that.getImaginary(), that.getReal()) + (2 * Math.PI)) % (2 * Math.PI));
    }

    // power spectral density
    this.getPS = function() {
      return (Math.pow(that.getReal(), 2) + Math.pow(that.getImaginary(), 2));
    }

    this.multiplyReal = function(re) {
      that.foil([re, 0]);
    }

    this.multiplyImaginary = function(im) {
      that.foil([0, im]);
    }

    this.foil = function(tuple) {
      // guard clause
      if(!(tuple instanceof Array)) {
        throw new TypeError(`${tuple} is not an instance of Array!`);
      }
      if(!(tuple.length === 2)) {
        throw new ValueError(`Invalid length of Array: ${tuple.length}`);
      }

      // Trivial to show when computed with two arbitrary elements in the set
      // of complex numbers
      that.setTuple([(that.getReal() * tuple[0]) - (that.getImaginary() *  tuple[1]),
        (that.getReal() * tuple[1]) + (that.getImaginary() * tuple[0])]);
    }

    this.clone = function() {
      return copy(that);
      //return new Complex(that.getReal(), that.getImaginary());
    }

    this.toString = function() {
      return `${that.getReal()} + ${that.getImaginary()}i`;
    }



    // ES6 does not allow tuples. We choose to treat
    // this instance like one (despite using an array for
    // the behavior).
    switch(args.length) {
      case 0:
      that.setTuple([0, 0]);
      break;
      case 2:
      that.setTuple(args);
      break;
      default:
      throw new ValueError(`Invalid number of arguments: ${args.length}`);
    }
  }
}

module.exports = {
  Complex: Complex
}


