"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InverseRealFFTConfig = exports.RealFFTConfig = exports.checkRealFFT = void 0;
const types_1 = require("./types");
const wasm_1 = require("./wasm");
function checkRealFFT(nfft) {
    if (nfft % 2 === 1) {
        throw new Error("Real FFT optimization must be even.");
    }
}
exports.checkRealFFT = checkRealFFT;
class AbstractRealFFTConfig extends types_1.KissFFTConfig {
    constructor(nfft, inverse) {
        super(nfft, inverse);
        this.ptr = 0;
        checkRealFFT(nfft);
        this.ptr = wasm_1.wasm._kiss_fftr_alloc(nfft, inverse, 0, 0);
    }
    get pointer() {
        return this.ptr;
    }
    free() {
        wasm_1.wasm._free(this.ptr);
        this.ptr = 0;
    }
}
class RealFFTConfig extends AbstractRealFFTConfig {
    constructor(nfft) {
        super(nfft, false);
    }
    work(input, output) {
        this.check(input, output);
        wasm_1.wasm._kiss_fftr(this.ptr, input.pointer, output.pointer);
    }
}
exports.RealFFTConfig = RealFFTConfig;
class InverseRealFFTConfig extends AbstractRealFFTConfig {
    constructor(nfft) {
        super(nfft, true);
    }
    work(input, output) {
        this.check(input, output);
        wasm_1.wasm._kiss_fftri(this.ptr, input.pointer, output.pointer);
        wasm_1.wasm._scale(output.pointer, this.nfft, 1.0 / this.nfft);
    }
}
exports.InverseRealFFTConfig = InverseRealFFTConfig;
//# sourceMappingURL=rfft.js.map