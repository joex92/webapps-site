"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InverseRealFFTNDConfig = exports.RealFFTNDConfig = void 0;
const types_1 = require("./types");
const rfft_1 = require("./rfft");
const wasm_1 = require("./wasm");
class AbstractRealFFTNDConfig extends types_1.KissFFTConfig {
    constructor(dims, inverse) {
        super(dims.reduce((x, y) => x * y), inverse);
        this.dims = dims;
        this.ptr = 0;
        const ndims = dims.length;
        rfft_1.checkRealFFT(dims[ndims - 1]);
        const dimsPtr = wasm_1.wasm._malloc(Int32Array.BYTES_PER_ELEMENT * ndims);
        dims.forEach((x, i) => {
            wasm_1.wasm.HEAP32[dimsPtr / Int32Array.BYTES_PER_ELEMENT + i] = x;
        });
        this.ptr = wasm_1.wasm._kiss_fftndr_alloc(dimsPtr, ndims, inverse, 0, 0);
        wasm_1.wasm._free(dimsPtr);
    }
    get pointer() {
        return this.ptr;
    }
    free() {
        wasm_1.wasm._free(this.ptr);
        this.ptr = 0;
    }
}
class RealFFTNDConfig extends AbstractRealFFTNDConfig {
    constructor(dims) {
        super(dims, false);
    }
    work(input, output) {
        this.check(input, output);
        wasm_1.wasm._kiss_fftndr(this.ptr, input.pointer, output.pointer);
    }
}
exports.RealFFTNDConfig = RealFFTNDConfig;
class InverseRealFFTNDConfig extends AbstractRealFFTNDConfig {
    constructor(dims) {
        super(dims, true);
    }
    work(input, output) {
        this.check(input, output);
        wasm_1.wasm._kiss_fftndri(this.ptr, input.pointer, output.pointer);
        wasm_1.wasm._scale(output.pointer, this.nfft, 1.0 / this.nfft);
    }
}
exports.InverseRealFFTNDConfig = InverseRealFFTNDConfig;
//# sourceMappingURL=rfftnd.js.map