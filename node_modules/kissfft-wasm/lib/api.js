"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.irfftnd = exports.irfft2d = exports.rfftnd = exports.rfft2d = exports.irfft = exports.rfft = exports.ifftnd = exports.ifft2d = exports.fftnd = exports.fft2d = exports.ifft = exports.fft = void 0;
const types_1 = require("./types");
const fft_1 = require("./fft");
const fftnd_1 = require("./fftnd");
const rfft_1 = require("./rfft");
const rfftnd_1 = require("./rfftnd");
function fftInner(config, inputType, outputType, input) {
    const inputArray = inputType.fromDataArray(input);
    const outputArray = new outputType(inputArray.length);
    config.work(inputArray, outputArray);
    const output = outputArray.toFloat32Array();
    for (const v of [config, inputArray, outputArray]) {
        v.free();
    }
    return output;
}
function makeDims(dims, args) {
    return typeof dims === "number" ? Array.from({
        length: args.length - 1
    }).map((_, i) => args[i + 1]) : dims;
}
// Forward 1D FFT
function fft(input) {
    return fftInner(new fft_1.FFTConfig(input.length / 2, false), types_1.ComplexArray, types_1.ComplexArray, input);
}
exports.fft = fft;
// Inverse 1D FFT
function ifft(input) {
    return fftInner(new fft_1.FFTConfig(input.length / 2, true), types_1.ComplexArray, types_1.ComplexArray, input);
}
exports.ifft = ifft;
// Forward 2D FFT
function fft2d(input, n, m) {
    return fftnd(input, n, m);
}
exports.fft2d = fft2d;
function fftnd(input, dims) {
    dims = makeDims(dims, arguments);
    return fftInner(new fftnd_1.FFTNDConfig(dims, false), types_1.ComplexArray, types_1.ComplexArray, input);
}
exports.fftnd = fftnd;
// Inverse 2D FFT
function ifft2d(input, n, m) {
    return ifftnd(input, n, m);
}
exports.ifft2d = ifft2d;
function ifftnd(input, dims) {
    dims = makeDims(dims, arguments);
    return fftInner(new fftnd_1.FFTNDConfig(dims, true), types_1.ComplexArray, types_1.ComplexArray, input);
}
exports.ifftnd = ifftnd;
// Forward Real 1D FFT
function rfft(input) {
    return fftInner(new rfft_1.RealFFTConfig(input.length), types_1.RealArray, types_1.ComplexArray, input);
}
exports.rfft = rfft;
// Inverse Real 1D FFT
function irfft(input) {
    return fftInner(new rfft_1.InverseRealFFTConfig(input.length / 2), types_1.ComplexArray, types_1.RealArray, input);
}
exports.irfft = irfft;
// Forward Real 2D FFT
function rfft2d(input, n, m) {
    return rfftnd(input, n, m);
}
exports.rfft2d = rfft2d;
function rfftnd(input, dims) {
    dims = makeDims(dims, arguments);
    return fftInner(new rfftnd_1.RealFFTNDConfig(dims), types_1.RealArray, types_1.ComplexArray, input);
}
exports.rfftnd = rfftnd;
// Inverse Real 2D FFT
function irfft2d(input, n, m) {
    return fftInner(new rfftnd_1.InverseRealFFTNDConfig([n, m]), types_1.ComplexArray, types_1.RealArray, input);
}
exports.irfft2d = irfft2d;
function irfftnd(input, dims) {
    dims = makeDims(dims, arguments);
    return fftInner(new rfftnd_1.InverseRealFFTNDConfig(dims), types_1.ComplexArray, types_1.RealArray, input);
}
exports.irfftnd = irfftnd;
//# sourceMappingURL=api.js.map